#version 460

#include "utils.glsl"

#line 6
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform sampler2D in_albedo;
layout(binding = 1) uniform sampler2D in_normal;
layout(binding = 2) uniform sampler2D in_depth;

layout(binding = 0) uniform writeonly image2D out_color;

layout(binding = 0) uniform Data {
	FrameData frame;
};

layout(binding = 1) buffer PointLights {
	PointLight point_lights[];
};

ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
vec2 image_size = vec2(textureSize(in_albedo, 0));
vec2 uv_coord = vec2(float(pixel_coord.x) + 0.5, float(pixel_coord.y) + 0.5) / image_size;

shared uint i_point_lights[64];
shared uint nb_point_lights = 0;

bool is_inside(PointLight light) {
	return true;
}

void determine_points_lights() {
	for (uint i = 0; i != frame.point_light_count; i++) {
		PointLight light = point_lights[i];
		if (is_inside(light)) {
			i_point_lights[nb_point_lights++] = i;
		}
	}
}

vec3 unproject(vec2 uv, float depth, mat4 inv_viewproj) {
	const vec3 ndc = vec3(uv, depth);
	const vec4 p = inv_viewproj * vec4(ndc, 1.0);
	return p.xyz/p.w;
}

void main() {
	if (gl_LocalInvocationID.yx == uvec2(1, 1))
	{
		nb_point_lights = 0;
		determine_points_lights();
	}
	groupMemoryBarrier();


	const vec3 normal = (texelFetch(in_normal, pixel_coord, 0).rgb) * 2.0 - 1.0;
	const vec3 albedo = texelFetch(in_albedo, pixel_coord, 0).rgb;
	const float depth = texelFetch(in_depth, pixel_coord, 0).r;

	vec3 acc = frame.sun_color * max(0.0, dot(frame.sun_dir, normal));
	for (uint i = 0; i != nb_point_lights; i++) {
		PointLight light = point_lights[i_point_lights[i]];
		
		const mat4 inv_viewproj = inverse(frame.camera.view_proj);

		const vec3 world_space_pos = unproject(uv_coord, depth, inv_viewproj);

		const vec3 to_light = (light.position - world_space_pos);
		const float dist = length(to_light);
		const vec3 light_vec = to_light / dist;

		const float NoL = max(dot(light_vec, normal), 0.0);
		const float att = attenuation(dist, light.radius, frame.falloff);

		acc += light.color * (NoL * att);
	}

	imageStore(out_color, pixel_coord, vec4(acc * albedo, 1.0));
}
